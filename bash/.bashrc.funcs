# .bashrc.funcs
#
# Generally useful bash functions
#
# Written in 2003-2017 by Aron Griffis <aron@arongriffis.com>
#
# To the extent possible under law, the author(s) have dedicated all copyright
# and related and neighboring rights to this software to the public domain
# worldwide. This software is distributed without any warranty.
#
# CC0 Public Domain Dedication at
# http://creativecommons.org/publicdomain/zero/1.0/
#======================================================================

[[ -n $_BASHRC_FUNCS ]] && return
_BASHRC_FUNCS=1

# isnfs -- Test if a filesystem is NFS-mounted
isnfs() {
  declare dfout 

  # Try to figure out what we're inspecting so we can safely call df.
  # Start by cleaning up $1 to look like a file and not a potential df
  # option.
  case "$1" in
    /*) set -- "$1" ;;
    *)  set -- "./$1" ;;
  esac

  # Check for existence of $1 prior to calling df.
  if [[ ! -e $1 ]]; then
    set -- "${1%/*}"            # remove trailing element
    [[ ! -e $1 ]] && set -- .   # doesnt exist, use cwd instead
  fi

  # Branch depending on OS where df has different options.
  case $OSTYPE in
    linux*|*bsd*|*BSD*)
      dfout=`/bin/df -l "$1" 2>/dev/null`
      case "$dfout" in
        */*) return 1 ;;  # looks like local
        *)   return 0 ;;  # looks like NFS
      esac
      ;;

    *)
      # pretend everything is NFS if we can't tell
      return 0
      ;;
  esac
}

# islocal -- Test if a filesystem is local (i.e. not NFS)
islocal() {
  declare d=$1
  [[ $d == . || $d == "PWD" || $d -ef $PWD ]] && d=$PWD
  [[ $d/ == /keybase/* ]] && return 1
  isnfs "$1" && return 1
  return 0
}

# designed to be overridden
isslow() {
  ! islocal "$1"
}

# readlink -- Emulate Linux's readlink binary.
if ! type -p readlink >/dev/null && type -p perl >/dev/null; then
  readlink() { perl -e 'print readlink($ARGV[0]), "\n"' "$1"; }
fi

prepend_sep() {
  declare var=$1 prev=${!1} sep=$2
  shift 2
  set -- "$@" ${prev:+"$prev"}
  declare IFS=$sep
  eval "$var=\$*"
}
append_sep() {
  declare var=$1 prev=${!1} sep=$2
  shift 2
  set -- ${prev:+"$prev"} "$@"
  declare IFS=$sep
  eval "$var=\$*"
}
prepend_sp() { prepend_sep "$1" ' ' "${@:2}"; }
append_sp() { append_sep "$1" ' ' "${@:2}"; }
prepend_cmd() { prepend_sep "$1" \; "${@:2}"; }
append_cmd() { append_sep "$1" \; "${@:2}"; }
prepend_line() { prepend_sep "$1" $'\n' "${@:2}"; }
append_line() { append_sep "$1" $'\n' "${@:2}"; }

# find_parent_with -- search for $1 in parent directories
find_parent_with() {
  declare far=false
  if [[ $1 == --far ]]; then
    far=true
    shift
  fi

  declare check=$PWD what=$1 stop=$2 found
  if [[ -z $stop || ! -d $stop ]]; then
    stop=$HOME
  fi

  while true; do
    if [[ -e $check/$what ]]; then
      found=$check
      $far || break
    fi
    if [[ -z $check || $check/. -ef $stop/. ]]; then
      break
    fi
    check=${check%/*}
  done

  if [[ -n $found ]]; then
    echo "$found"
    return 0
  else
    return 1
  fi
}

bool() {
  "$@" && echo true || echo false
}

not() {
  "$@" && echo false || echo true
}

# color -- emit ansi color codes
color() {
  declare bright=false inverse=false bg=false color code true
  while [[ $# -gt 0 ]]; do
    case $1 in
      fg) bg=$inverse ;;  # default
      bg|on) bg=$(not $inverse) ;;
      bright) bright=true ;;
      reset|off) code=0 ;;
      bold) code=1 ;;
      inverse) inverse=true; bg=$(not $bg); code=7 ;;
      default) $bg && code=49 || code=39 ;;
      black) color=0 ;;
      red) color=1 ;;
      green) color=2 ;;
      yellow) color=3 ;;
      blue) color=4 ;;
      magenta) color=5 ;;
      cyan) color=6 ;;
      white) color=7 ;;
      '#'??????) true=${1:1} ;;
      '#'???) true=${1:1:1}${1:1:1}${1:2:1}${1:2:1}${1:3:1}${1:3:1} ;;
      *[!0-9]*) echo "unknown color: $1" >&2 ;;
      ?*) color=$1 ;;
    esac
    if [[ -n $color ]]; then
      $bright && ((color < 8)) && ((color += 8))
      $bg && code=48 || code=38
      code="$code;5;$color"
    elif [[ -n $true ]]; then
      $bg && code='48;2;' || code='38;2;'
      code+=$(printf '%d;%d;%d' "0x${true:0:2}" "0x${true:2:2}" "0x${true:4}")
    fi
    if [[ -n $code ]]; then
      echo -ne "\033[${code}m"
      bright=false code= color= true=
    fi
    shift
  done
}

# cursorpos -- Echo the current cursor row and column
cursorpos() {
  (
    exec < /dev/tty
    oldstty=$(stty -g)
    stty raw -echo min 0
    echo -en '\033[6n' > /dev/tty
    IFS='[;' read -r -d R -a pos
    stty $oldstty
    echo "${pos[@]:1}"
  )
}

# funcdup -- Duplicate a function
funcdup() {
  declare x="#$(type $1)"
  if [[ $x != "#$1 is a function"* ]]; then
    echo "$FUNCNAME called for non-function $1" >&2
    return 1
  fi
  x=${x/$1 ()/$2 ()}
  [[ -n $3 ]] && eval "$3"
  eval "$x"
}

# echo1 -- echo the first positional parameter,
# for getting the first element from a globbed list
echo1() {
  echo "$1"
}

# setarray -- use temporary IFS $3 to parse $2 to an array $1
setarray() {
  declare IFS=$3
  eval "$1=( \$2 )"
}

# arrayhas -- look for $2 in array $1
arrayhas() {
  declare x
  eval "for x in \"\${$1[@]}\"; do
    [[ \$x == \$2 ]] && return 0
  done"
  return 1
}

# This is a function rather than a script in skel/bin because we use it in
# bashrc.prompt, which should only depend on bashrc.funcs
distro() {
  declare distro
  if [[ -e /etc/lsb-release ]]; then
    distro=$(
      source /etc/lsb-release
      echo -n "$DISTRIB_ID"
      [[ -n $DISTRIB_RELEASE ]] && echo -n " $DISTRIB_RELEASE"
      [[ -n $DISTRIB_CODENAME ]] && echo -n " ($DISTRIB_CODENAME)"
    )
  fi
  if [[ -z $distro ]]; then
    if [[ -e /etc/debian_version ]]; then
      distro=$(</etc/debian_version)
    elif [[ -e /etc/redhat-release ]]; then
      distro=$(</etc/redhat-release)
      distro=${distro/#Red Hat Enterprise Linux*release/RHEL}
    elif [[ -e /etc/SuSE-release ]]; then
      distro=$(grep '^Welcome' /etc/issue)
      : ${distro:=$(head -n1 /etc/SuSE-release)}
      distro=${distro#Welcome to }
      distro=${distro/#SUSE Linux Enterprise Server/SLES}
    elif [[ -e /etc/gentoo-release ]]; then
      distro=$(</etc/gentoo-release)
    else
      distro=unknown
    fi
    distro=${distro%% (*)*}
  fi
  distro="$distro $(uname -r)"
  echo "$distro"
}

first_test() {
  declare t x
  t=$1; shift
  for x; do
    if test $t "$x"; then
      echo "$x"
      return 0
    fi
  done
  return 1
}

# The following lines enforce a consistent indentation for this file.
# Keep this comment at the end of file.
#
# Local Variables:
# mode: shell-script
# sh-basic-offset: 2
# sh-indentation: 2
# evil-shift-width: 2
# indent-tabs-mode: nil
# End:
#
# vim:shiftwidth=2 expandtab smarttab
