# $Id: bashrc.pathfuncs 4744 2012-08-12 14:49:17Z aron $
#
# bashrc.pathfuncs
#       Functions for manipulating PATH-like variables
#
# Copyright 2003-2007 Aron Griffis <agriffis n01se.net>
# Originally released under the GNU GPL v2.
# Released under the MIT license on December 15, 2009, as shown below:
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
####################################################################### 

[[ -n $_BASHRC_PATHFUNCS ]] && return
_BASHRC_PATHFUNCS=1

# Wrap path functions under a single path command.
path() {
  declare cmd=$1

  case $1 in
    add|append) cmd=addpath ;;
    front|prepend) cmd=frontpath ;;
    rm|remove) cmd=rmpath ;;
    clean) cmd=cleanpath ;;
    has) cmd=haspath ;;
    *) echo "Unknown path command: $1" >&2; return 1 ;;
  esac

  $cmd "${@:2}"
}

# haspath -- Test if element exists in PATHvar
# syntax: haspath PATHvar element
# example:
#     if haspath PATH /usr/bin; then
#       echo "Your PATH contains /usr/bin"
#     fi
haspath() {
  declare curpath=${!1}
  case $curpath in
    $2|$2:*|*:$2|*:$2:*) return 0 ;;
    *) return 1 ;;
  esac
}

# inpath -- Test if *executable* is found in the PATH
# syntax: inpath executable
# example:
#     if inpath sawfish; then
#       echo "sawfish is in the path"
#     fi
inpath() {
  # compatibility, since haspath used to be called inpath
  if [[ $* == */* ]]; then
    haspath "$@"
  else
    type -P "$1" &>/dev/null
  fi
}

# rmpath -- Remove all occurences of each element from PATHvar
# syntax: rmpath PATHvar element1 [ element2 ... ]
# example:
#     rmpath MANPATH /usr/local/man
rmpath() {
  declare e newpath oldpath=${!1} PATHvar=$1 thisp IFS=:
  shift
  for thisp in $oldpath; do
    for e; do [[ $thisp == $e ]] && continue 2; done
    newpath=$newpath:$thisp
  done
  eval "$PATHvar=\${newpath#:}"
}

# frontpath -- Prepend elements to PATHvar (and remove other occurences)
# syntax: frontpath PATHvar element1 [ element2 ... ]
# Remove all occurences of each element, then prepend elements
frontpath() {
  rmpath $1 "${@:2}"
  declare IFS=:
  # double-quotes required to interpolate IFS in $*
  eval "$1=\"\${*:2}\${$1:+:\$$1}\""
}

# addpath -- Append elements to PATHvar (and remove other occurences)
# syntax: addpath PATHvar element1 [ element2 ... ]
# Remove all occurences of each element, then append elements
addpath() {
  rmpath $1 "${@:2}"
  declare IFS=:
  # double-quotes required to interpolate IFS in $*
  eval "$1=\"\${$1:+\$$1:}\${*:2}\""
}

# cleanpath -- Remove duplicate elements and doubled slashes
# syntax: cleanpath PATHvar
# Clean up PATHvar by removing duplicate elements and doubled slashes
cleanpath() {
  declare e newpath oldpath=${!1} PATHvar=$1 IFS

  # Get rid of doubled slashes
  while [[ $oldpath == *//* ]]; do 
    oldpath=${oldpath%%//*}/${oldpath#*//}
  done

  # Remove duplicate elements
  IFS=':'
  for e in $oldpath; do
    # Remove trailing slash; the ? is to prevent removal of root dir!
    [[ $e == *?/ ]] && e=${e%/}
    # Append to newpath if not seen yet
    case :$newpath: in
      *:$e:*) continue ;;
      *) newpath="$newpath:$e" ;;
    esac
  done
  eval "$PATHvar='${newpath#:}'"
}

# The following line enforces a consistent indentation for this file
# (in Vim at least).  Keep this at the end of file.
# vim:shiftwidth=2 expandtab smarttab
