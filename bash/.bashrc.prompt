# .bashrc.prompt
#
# Multi-line modular prompt
#
# Written in 2003-2017 by Aron Griffis <aron@arongriffis.com>
#
# To the extent possible under law, the author(s) have dedicated all copyright
# and related and neighboring rights to this software to the public domain
# worldwide. This software is distributed without any warranty.
#
# CC0 Public Domain Dedication at
# http://creativecommons.org/publicdomain/zero/1.0/
#======================================================================

[[ -n $_BASHRC_PROMPT ]] && return
_BASHRC_PROMPT=1

[[ -n $_BASHRC_FUNCS ]] || source ~/.bashrc.funcs

# Default colors, overrideable in user .bashrc
: ${PS1_COLOR_DEFAULT_FG:=white}
: ${PS1_COLOR_DEFAULT_BG:=blue}
: ${PS1_COLOR_SUCCESS_FG:=$PS1_COLOR_DEFAULT_FG}
: ${PS1_COLOR_SUCCESS_BG:=green}
: ${PS1_COLOR_WARNING_FG:=black}
: ${PS1_COLOR_WARNING_BG:=yellow}
: ${PS1_COLOR_ERROR_FG:=$PS1_COLOR_DEFAULT_FG}
: ${PS1_COLOR_ERROR_BG:=red}
: ${PS1_CHAR_OK:=$'\uf00c'}           # ÔÄå  (fontawesome)
: ${PS1_CHAR_UGH:=$'\uf00d'}          # ÔÄç  (fontawesome)
: ${PS1_CHAR_RARR:=$'\uE0B1'}         # ÓÇ±  (powerline)
: ${PS1_CHAR_RARR_FILLED:=$'\uE0B0'}  # ÓÇ∞  (powerline)
: ${PS1_CHAR_BRANCH:=$'\uE725'}       # Óú•  (devicons)
: ${PS1_CHAR_DIRTY:=$'\uF069'}        # ÔÅ©  (fontawesome)
: ${PS1_CHAR_STAGED:=$'\uF067'}       # ÔÅß  (fontawesome)
: ${PS1_CHAR_BISECT:=$'\ue728'}       # (devicons)
: ${PS1_CHAR_MERGE:=$'\ue726'}        # (devicons)
: ${PS1_CHAR_REBASE:=$'\ue726'}       # (devicons)
: ${PS1_CHAR_HG:=$'\u263F'}           # ‚òø  (unicode)
: ${PS1_CHAR_SVN:=$'\U1D5E6'}         # ùó¶  (unicode)
: ${PS1_CHAR_PYTHON:=$'\ue73c'}       # Óúº  (devicons)
: ${PS1_CHAR_RUBY:=$'\ue739'}         # Óúπ  (devicons)

# Modules that want to cache information between calls can use these
# functions.
unset PS1_CACHE
declare -A PS1_CACHE
ps1_cache_get() { echo "${PS1_CACHE[$1]:-$2}"; }
ps1_cache_set() { PS1_CACHE[$1]=$2; }
ps1_cache_del() { unset PS1_CACHE[$1]; }

# Old-style cache
unset ${!PS1_CACHE_*}

# Utility functions to be called by modules:
# ps1 ............... color but wrap in \[ \] for bash's PS1 parsing
# ps1_quote ......... escape backslashes and dollar signs
# ps1_segment ....... add a segment to the prompt
# ps1_status ........ call ps1_segment with default colors
ps1() {
  printf '\[%s\]' "$(color "$@")"
}

ps1_quote() {
  # this requires quoting specifically backquotes, backslashes and dollars,
  # not the full printf %q treatment
  declare q=$1
  q=${q//\\/\\\\}
  q=${q//\$/\\\$}
  q=${q//\`/\\\`}
  # don't take chances with echo...
  printf '%s' "$q"
}

ps1_segment() {
  declare n="$1" fg="$2" bg="$3" s="$4"

  # powerline transition
  # NB: reset to kill inverse
  if [[ -n $PS1 ]]; then
    declare prevbg="$(ps1_cache_get _BG default)"
    if [[ "$bg" != "$prevbg" ]]; then
      PS1+=" $(ps1 reset $prevbg bg $bg)$PS1_CHAR_RARR_FILLED"
    else
      PS1+=" $(ps1 reset bg $bg)$PS1_CHAR_RARR"
    fi
  fi

  # add this segment
  PS1+="$(ps1 $fg bg $bg) $s"
  
  # reset colors in case $s has embedded
  PS1+="$(ps1 $fg bg $bg)"

  # update fgbg cache
  _ps1_cache_fgbg $fg bg $bg
}

_ps1_cache_fgbg() {
  # keep a cache of the current fg and bg colors
  # by parsing the ps1/color command-line.
  declare x g=fg s=()
  for x in "$@" SENTINAL; do
    if [[ $x == +(bg|fg|on|SENTINAL) ]]; then
      [[ $x == on ]] && x=bg
      [[ $x == $g ]] && continue
      [[ -n $s ]] && ps1_cache_set _${g^^} "${s[*]}"
      g=$x s=()
    elif [[ $x == +(off|reset) ]]; then
      ps1_cache_del _FG
      ps1_cache_del _BG
    else
      s+=($x)
    fi
  done
}

ps1_status() {
  ps1_segment 0 "$PS1_COLOR_DEFAULT_FG" "$PS1_COLOR_DEFAULT_BG" "$(ps1_quote "$1")"
}

# The module system defines an array of modules which will be called in order by
# the function ps1_update (defined near the end of this file).  Each module
# defines a function and the registers itself, for example:
#    ps1_mod_foo() {
#      ps1_status "foo to you!"
#    }
#    ps1_register_module foo
#
# It's also possible for the user to unregister default modules they dislike,
# after sourcing .bashrc.prompt, for example:
#    source ~/.bashrc.prompt
#    ps1_unregister_module svk
PS1_MODULES=()
ps1_register_module() {
  declare mod="$1" position="$2" relative="$3"
  ps1_unregister_module "$mod"
  case $position in
    first)
      PS1_MODULES=("$mod" "${PS1_MODULES[@]}")
      return ;;
    before|after)
      declare i
      for ((i=0; i<${#PS1_MODULES[@]}; i++)); do
        if [[ "${PS1_MODULES[i]}" == "$relative" ]]; then
          [[ $position == before ]] || (( i++ ))
          PS1_MODULES=("${PS1_MODULES[@]::i}" "$mod" "${PS1_MODULES[@]:i}")
          return
        fi
      done ;;
  esac
  PS1_MODULES+=("$mod")
}
ps1_unregister_module() {
  declare m n
  declare -a mods
  for m in "${PS1_MODULES[@]}"; do
    for n; do
      [[ $m == "$n" ]] && continue 2
    done
    mods=("${mods[@]}" "$m")
  done
  PS1_MODULES=("${mods[@]}")
}

# MODULE: micro status
ps1_micro() { true; }
ps1_mod_micro() {
  ps1_cache_set MICRO ''
  # 243 is a grayscale in the 256-color space.
  # https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
  ps1_segment 0 white 243 '__MICRO_PLACEHOLDER__'
  ps1_micro() {
    declare m=$(ps1_cache_get MICRO)
    ps1_cache_set MICRO "$m${m:+ }$*"
  }
}
ps1_mod_micro_postprocess() {
  PS1=${PS1/__MICRO_PLACEHOLDER__/$(ps1_cache_get MICRO)}
}
ps1_register_module micro

# MODULE: error status
ps1_mod_error() {
  # call ps1_segment directly, rather than ps1_status, for unescaped \w
  if [[ ${PS1_ERROR:-0} == 0 ]]; then
    ps1_micro "$(ps1 bright green)$PS1_CHAR_OK"
  else
    ps1_micro "$(ps1 bright red)$PS1_CHAR_UGH"
  fi
}
ps1_register_module error

# MODULE: user and host
ps1_mod_user() {
  ps1_segment 0 "$PS1_COLOR_DEFAULT_FG" "$PS1_COLOR_DEFAULT_BG" '\u@\h'
}
#ps1_register_module user

# MODULE: current working directory
ps1_mod_cwd() {
  # call ps1_segment directly, rather than ps1_status, for unescaped \w
  ps1_segment 0 "$PS1_COLOR_DEFAULT_FG" "$PS1_COLOR_DEFAULT_BG" '\w'
}
ps1_register_module cwd

# MODULE: virtualenv -- show the current python virtualenv
ps1_mod_virtualenv() {
  if [[ -n $VIRTUAL_ENV ]]; then
    ps1_micro "$(ps1 bright blue)$PS1_CHAR_PYTHON"
  fi
}
ps1_register_module virtualenv

# MODULE: rvm -- show the current ruby environment
ps1_mod_rvm() {
  if [[ -n $GEM_HOME ]]; then
    ps1_micro "$(ps1 bright red)$PS1_CHAR_RUBY"
  fi
}
ps1_register_module rvm

# MODULE: hg -- show some mercurial information
ps1_mod_hg() {
  $PS1_CACHE_ISSLOW_CWD && return 1
  if [[ $PS1_CACHE_HG_CWD != "$PWD" ]]; then
    PS1_CACHE_HG_TOP=$(find_parent_with .hg)
    PS1_CACHE_HG_CWD=$PWD
  fi
  declare top=$PS1_CACHE_HG_TOP
  [[ -n $top ]] || return

  declare topkey cachetime hgtime summary

  # consult our cache for hg info
  topkey=${top//[![A-Za-z0-9]/_}
  cachetime=$(ps1_cache_get "HG_${topkey}_TIME")
  hgtime=$(TZ=UTC stat --format=%y "$top"/.hg/*)
  if [[ "$cachetime" != "$hgtime" ]]; then
    ps1_cache_set "HG_${topkey}_SUMMARY" "$(hg -R $top summary)"
    ps1_cache_set "HG_${topkey}_TIME" "$hgtime"
  fi
  summary=$(ps1_cache_get "HG_${topkey}_SUMMARY")
  [[ -n $summary ]] || return

  declare branch dirty fg bg
  branch=$(awk '$1=="branch:"{print $2}' <<<"$summary")
  dirty=$(hg -R $top status -q | grep -q . && echo "$PS1_CHAR_DIRTY ")
  if [[ -n $dirty ]]; then
    fg=$PS1_COLOR_WARNING_FG bg=$PS1_COLOR_WARNING_BG
  else
    fg=$PS1_COLOR_SUCCESS_FG bg=$PS1_COLOR_SUCCESS_BG
  fi
  ps1_segment 0 "$fg" "$bg" "$(ps1_quote "$PS1_CHAR_HG $branch$dirty")"
}
ps1_register_module hg

# MODULE: git -- show the current git branch
ps1_mod_git() {
  $PS1_CACHE_ISSLOW_CWD && return 1
  if [[ $PS1_CACHE_GIT_CWD != "$PWD" ]]; then
    PS1_CACHE_GIT_TOP=$(find_parent_with .git/HEAD)
    PS1_CACHE_GIT_CWD=$PWD
  fi
  declare top="$PS1_CACHE_GIT_TOP"
  [[ -n $top ]] || return

  declare status=$(git -C "$top" status --short --branch --untracked-files=no)
  [[ -n $status ]] || return

  declare branch dirty fg bg
  branch=${status#?? }; branch=${branch%%[.$'\n']*}
  [[ $status == *$'\n'* ]] && status=${status#*$'\n'} || status=''
  if [[ -e $top/.git/BISECT_LOG ]]; then
    dirty="$PS1_CHAR_BISECT "
  elif [[ -e $top/.git/MERGE_HEAD ]]; then
    dirty="$PS1_CHAR_MERGE "
  elif [[ -e $top/.git/rebase-merge ]]; then
    dirty="$PS1_CHAR_REBASE "
  elif [[ $'\n'$status == *$'\n'?[!\ ]* ]]; then
    dirty="$PS1_CHAR_DIRTY "
  elif [[ $'\n'$status == *$'\n'[!\ ]* ]]; then
    dirty="$PS1_CHAR_STAGED "
  fi
  if [[ -n $dirty ]]; then
    fg=$PS1_COLOR_WARNING_FG bg=$PS1_COLOR_WARNING_BG
  else
    fg=$PS1_COLOR_SUCCESS_FG bg=$PS1_COLOR_SUCCESS_BG
  fi
  ps1_segment 0 "$fg" "$bg" "$(ps1_quote "$PS1_CHAR_BRANCH $branch$dirty")"
}
ps1_register_module git

# MODULE: svn -- show the subversion source and revision
ps1_mod_svn() {
  $PS1_CACHE_ISSLOW_CWD && return 1
  if [[ $PS1_CACHE_SVN_CWD != "$PWD" ]]; then
    PS1_CACHE_SVN_TOP=$(find_parent_with --far .svn)
    PS1_CACHE_SVN_CWD=$PWD
  fi
  declare top=$PS1_CACHE_SVN_TOP
  [[ -n $top ]] || return

  declare rev
  declare rev=$(svn info $top 2>/dev/null | while read data; do
      case $data in
        (Revision:*) echo "${data#*: }" ;;
      esac
    done)
  [[ -n $rev ]] || return

  declare dirty fg bg
  dirty=$(svn status -q | grep -q . && echo "$PS1_CHAR_DIRTY ")
  if [[ -n $dirty ]]; then
    fg=$PS1_COLOR_WARNING_FG bg=$PS1_COLOR_WARNING_BG
  else
    fg=$PS1_COLOR_SUCCESS_FG bg=$PS1_COLOR_SUCCESS_BG
  fi
  ps1_segment 0 "$fg" "$bg" "$(ps1_quote "$PS1_CHAR_SVN $rev$dirty")"
}
ps1_register_module svn

# The ps1_update function calls the modules defined above and in the user
# bashrc to construct the full prompt.
ps1_update() {
  declare cwd=${PWD/#$HOME/\~} user=$USER host=${HOSTNAME%%.*}
  declare leader=${PS1_LEADER:-'---'} trailer=${PS1_TRAILER:-'---'}
  declare line width x pad

  # help out the modules by caching isslow for cwd
  if [[ -z $PS1_CACHE_ISSLOW_CWD || $PWD != "$PS1_CACHE_CWD" ]]; then
    if [[ $PWD == "$HOME" ]]; then
      : ${PS1_CACHE_ISSLOW_HOME:=$(isslow . && echo true || echo false)}
      PS1_CACHE_ISSLOW_CWD=$PS1_CACHE_ISSLOW_HOME
    else
      PS1_CACHE_ISSLOW_CWD=$(isslow . && echo true || echo false)
    fi
    PS1_CACHE_CWD=$PWD
  fi

  # clean slate
  PS1=

  # run the status line modules
  PS1_CACHE_MODS_RAN=()
  for x in "${PS1_MODULES[@]}"; do
    ps1_mod_"$x" && PS1_CACHE_MODS_RAN=( "${PS1_CACHE_MODS_RAN[@]}" "$x" )
  done

  # cap it off
  PS1+=$(
    if [[ $(ps1_cache_get _BG default) != default ]]; then
      ps1 reset $(ps1_cache_get _BG)  # reset to kill inverse
      echo -n "$PS1_CHAR_RARR_FILLED "
      ps1 off
    else
      ps1 off
      echo -n "${PS1:+ }$PS1_CHAR_RARR "
    fi
  )

  # postprocess
  for x in "${PS1_CACHE_MODS_RAN[@]}"; do
    x="ps1_mod_${x}_postprocess"
    [[ $(type -t "$x") != function ]] || "$x"
  done
}

# Okay, all functions are defined, now set up PROMPT_COMMAND to make sure things
# are called.  First capture the error status, second save and unset -x, third
# call our ps1_update function, fourth set the xterm title, fifth reset -x.

PROMPT_COMMAND='PS1_ERROR=$?'
append_cmd PROMPT_COMMAND 'PS1_SAVE_SET_X=${-//[^x]/}; [[ -n $PS1_DEBUG ]] || set +x'
append_cmd PROMPT_COMMAND ps1_update
case "$TERM" in
  xterm*|gnome|rxvt*|vte*)
    ps1_update_xterm_title() {
      declare title=${1:-$XTERMTITLE}
      if [[ -z $title ]]; then
        if [[ -n $CHROOTED ]]; then
          title="($CHROOTED):${PWD/#$HOME/~}"
        else
          title="${HOSTNAME%%.*}:${PWD/#$HOME/~}"
        fi
      fi
      echo -ne '\033]0;'
      echo -n "$title"
      echo -ne '\007'
    }
    append_cmd PROMPT_COMMAND ps1_update_xterm_title
    ;;
esac
append_cmd PROMPT_COMMAND '[[ -n $PS1_SAVE_SET_X ]] && set -x'

# The following lines enforce a consistent indentation for this file.
# Keep this comment at the end of file.
#
# Local Variables:
# mode: shell-script
# sh-basic-offset: 2
# indent-tabs-mode: nil
# End:
#
# vim:shiftwidth=2 expandtab smarttab
