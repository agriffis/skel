# .bashrc.prompt
#
# Multi-line modular prompt
#
# Written in 2003-2017 by Aron Griffis <aron@arongriffis.com>
#
# To the extent possible under law, the author(s) have dedicated all copyright
# and related and neighboring rights to this software to the public domain
# worldwide. This software is distributed without any warranty.
#
# CC0 Public Domain Dedication at
# http://creativecommons.org/publicdomain/zero/1.0/
#======================================================================

[[ -n $_BASHRC_PROMPT ]] && return
_BASHRC_PROMPT=1

[[ -n $_BASHRC_FUNCS ]] || source ~/.bashrc.funcs

# Default colors, overrideable in user .bashrc
: ${PS1_COLOR_DEFAULT_FG:=white}
: ${PS1_COLOR_DEFAULT_BG:=blue}
: ${PS1_COLOR_SUCCESS_FG:=$PS1_COLOR_DEFAULT_FG}
: ${PS1_COLOR_SUCCESS_BG:=green}
: ${PS1_COLOR_WARNING_FG:=black}
: ${PS1_COLOR_WARNING_BG:=yellow}
: ${PS1_COLOR_ERROR_FG:=$PS1_COLOR_DEFAULT_FG}
: ${PS1_COLOR_ERROR_BG:=red}
: ${PS1_CHAR_OK:=$'\uf00c'}           # ÔÄå  (fontawesome)
: ${PS1_CHAR_UGH:=$'\uf00d'}          # ÔÄç  (fontawesome)
: ${PS1_CHAR_SEP:=$'\uE0B1'}          # ÓÇ±  (powerline)
: ${PS1_CHAR_SEP_FILLED:=$'\uE0B0'}   # ÓÇ∞  (powerline)
: ${PS1_CHAR_BRANCH:=$'\uE725'}       # Óú•  (devicons)
: ${PS1_CHAR_DIRTY:=$'\uF069'}        # ÔÅ©  (fontawesome)
: ${PS1_CHAR_STAGED:=$'\uF067'}       # ÔÅß  (fontawesome)
: ${PS1_CHAR_BISECT:=$'\ue728'}       # Óú®  (devicons)
: ${PS1_CHAR_MERGE:=$'\ue726'}        # Óú¶  (devicons)
: ${PS1_CHAR_REBASE:=$'\ue726'}       # Óú¶  (devicons)
: ${PS1_CHAR_HG:=$'\u263F'}           # ‚òø  (unicode)
: ${PS1_CHAR_SVN:=$'\U1D5E6'}         # ùó¶  (unicode)
: ${PS1_CHAR_PYTHON:=$'\ue73c'}       # Óúº  (devicons)
: ${PS1_CHAR_RUBY:=$'\ue739'}         # Óúπ  (devicons)

# Modules that want to cache information between calls can use these
# functions.
unset PS1_CACHE
declare -A PS1_CACHE
ps1_cache_get() { echo "${PS1_CACHE[$1]:-$2}"; }
ps1_cache_set() { PS1_CACHE[$1]=$2; }
ps1_cache_del() { unset PS1_CACHE[$1]; }

# Old-style cache
unset ${!PS1_CACHE_*}

# Utility functions to be called by modules:
# ps1_color ......... color but wrap in \[ \] for bash's PS1 parsing
# ps1_quote ......... escape backslashes and dollar signs
# ps1_segment ....... add a segment to the prompt
# ps1_status ........ call ps1_segment with default colors
ps1_color() {
  printf '\[%s\]' "$(color "$@")"
}

ps1_quote() {
  # this requires quoting specifically backquotes, backslashes and dollars,
  # not the full printf %q treatment
  declare q=$1
  q=${q//\\/\\\\}
  q=${q//\$/\\\$}
  q=${q//\`/\\\`}
  # don't take chances with echo...
  printf '%s' "$q"
}

ps1_segment() {
  _ps1_segment "$1" "$2" "$(ps1_quote "$3")"
}

_ps1_segment() {
  declare fg="$1" bg="$2" s="$3"

  # powerline transition
  # NB: reset to kill inverse
  if [[ -n $PS1 ]]; then
    declare prevbg="$(ps1_cache_get _BG default)"
    if [[ "$bg" != "$prevbg" ]]; then
      PS1+=" $(ps1_color reset $prevbg bg $bg)$PS1_CHAR_SEP_FILLED"
    else
      PS1+=" $(ps1_color reset bg $bg)$PS1_CHAR_SEP"
    fi
  fi

  # add this segment
  PS1+="$(ps1_color $fg bg $bg) $s"

  # reset colors in case $s has embedded
  PS1+="$(ps1_color $fg bg $bg)"

  # update fgbg cache
  _ps1_cache_fgbg $fg bg $bg
}

_ps1_cache_fgbg() {
  # track the current fg and bg colors by parsing the ps1_color args.
  declare x g=fg s=()
  for x in "$@" SENTINAL; do
    if [[ $x == +(bg|fg|on|SENTINAL) ]]; then
      [[ $x == on ]] && x=bg
      [[ $x == $g ]] && continue
      [[ -n $s ]] && ps1_cache_set _${g^^} "${s[*]}"
      g=$x s=()
    elif [[ $x == +(off|reset) ]]; then
      ps1_cache_del _FG
      ps1_cache_del _BG
    else
      s+=($x)
    fi
  done
}

ps1_status() {
  ps1_segment "$PS1_COLOR_DEFAULT_FG" "$PS1_COLOR_DEFAULT_BG" "$1"
}

# The module system defines an array of modules which will be called in order by
# the function ps1_update (defined near the end of this file).  Each module
# defines a function and the registers itself, for example:
#    ps1_mod_foo() {
#      ps1_status "foo to you!"
#    }
#    ps1_register_module foo
#
# It's also possible for the user to unregister default modules they dislike,
# after sourcing .bashrc.prompt, for example:
#    source ~/.bashrc.prompt
#    ps1_unregister_module svk
PS1_MODULES=()
ps1_register_module() {
  declare mod="$1" position="$2" relative="$3"
  ps1_unregister_module "$mod"
  case $position in
    first)
      PS1_MODULES=("$mod" "${PS1_MODULES[@]}")
      return ;;
    before|after)
      declare i
      for ((i=0; i<${#PS1_MODULES[@]}; i++)); do
        if [[ "${PS1_MODULES[i]}" == "$relative" ]]; then
          [[ $position == before ]] || (( i++ ))
          PS1_MODULES=("${PS1_MODULES[@]::i}" "$mod" "${PS1_MODULES[@]:i}")
          return
        fi
      done ;;
  esac
  PS1_MODULES+=("$mod")
}
ps1_unregister_module() {
  declare m n
  declare -a mods
  for m in "${PS1_MODULES[@]}"; do
    for n; do
      [[ $m == "$n" ]] && continue 2
    done
    mods=("${mods[@]}" "$m")
  done
  PS1_MODULES=("${mods[@]}")
}

# MODULE: micro status
ps1_micro() { true; }  # in case micro mod not registered
ps1_mod_micro() {
  ps1_cache_set MICRO ''
  # 243 is a grayscale in the 256-color space.
  # https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
  _ps1_segment white 243 '__MICRO_PLACEHOLDER__'
  ps1_micro() {
    declare m=$(ps1_cache_get MICRO)
    ps1_cache_set MICRO "$m${m:+ }$*"
  }
}
ps1_mod_micro_postprocess() {
  PS1=${PS1/__MICRO_PLACEHOLDER__/$(ps1_cache_get MICRO)}
}
ps1_register_module micro

# MODULE: error status
ps1_mod_error() {
  if [[ ${PS1_ERROR:-0} == 0 ]]; then
    ps1_micro "$(ps1_color bright green)$PS1_CHAR_OK"
  else
    ps1_micro "$(ps1_color bright red)$PS1_CHAR_UGH"
  fi
}
ps1_register_module error

# MODULE: virtualenv -- show the current python virtualenv
ps1_mod_virtualenv() {
  if [[ -n $VIRTUAL_ENV ]]; then
    ps1_micro "$(ps1_color bright blue)$PS1_CHAR_PYTHON"
  fi
}
ps1_register_module virtualenv

# MODULE: rvm -- show the current ruby environment
ps1_mod_rvm() {
  if [[ -n $GEM_HOME ]]; then
    ps1_micro "$(ps1_color bright red)$PS1_CHAR_RUBY"
  fi
}
ps1_register_module rvm

# MODULE: hg -- show some mercurial information
ps1_mod_hg() {
  $(ps1_cache_get _CWD_IS_SLOW) && return 1
  if [[ -e .hg ]]; then
    ps1_cache_set HG_TOP "$PWD"
  elif [[ $(ps1_cache_get HG_CWD) != "$PWD" ]]; then
    ps1_cache_set HG_TOP "$(find_parent_with .hg)"
  fi
  ps1_cache_set HG_CWD "$PWD"
  declare top=$(ps1_cache_get HG_TOP)
  [[ -n $top ]] || return

  declare cachetime hgtime summary

  # consult our cache for hg info
  cachetime=$(ps1_cache_get "HG_CACHE_TIME $top")
  hgtime=$(TZ=UTC stat --format=%y "$top"/.hg/*)
  if [[ "$cachetime" != "$hgtime" ]]; then
    ps1_cache_set "HG_SUMMARY $top" "$(hg -R $top summary)"
    ps1_cache_set "HG_TIME $top" "$hgtime"
  fi
  summary=$(ps1_cache_get "HG_SUMMARY $top")
  [[ -n $summary ]] || return

  declare branch dirty fg bg
  branch=$(awk '$1=="branch:"{print $2}' <<<"$summary")
  dirty=$(hg -R $top status -q | grep -q . && echo "$PS1_CHAR_DIRTY ")
  if [[ -n $dirty ]]; then
    fg=$PS1_COLOR_WARNING_FG bg=$PS1_COLOR_WARNING_BG
  else
    fg=$PS1_COLOR_SUCCESS_FG bg=$PS1_COLOR_SUCCESS_BG
  fi
  ps1_segment "$fg" "$bg" "$PS1_CHAR_HG $branch$dirty"
}
ps1_register_module hg

# MODULE: git -- show the current git branch
ps1_mod_git() {
  $(ps1_cache_get _CWD_IS_SLOW) && return 1
  if [[ -e .git/HEAD ]]; then
    ps1_cache_set GIT_TOP "$PWD"
  elif [[ $(ps1_cache_get GIT_CWD) != "$PWD" ]]; then
    ps1_cache_set GIT_TOP "$(find_parent_with .git/HEAD)"
  fi
  ps1_cache_set GIT_CWD "$PWD"
  declare top="$(ps1_cache_get GIT_TOP)"
  [[ -n $top ]] || return

  declare status=$(git -C "$top" status --short --branch --untracked-files=no)
  [[ -n $status ]] || return

  declare branch dirty fg bg
  branch=${status#?? }; branch=${branch%%[.$'\n']*}
  [[ $status == *$'\n'* ]] && status=${status#*$'\n'} || status=''
  if [[ -e $top/.git/BISECT_LOG ]]; then
    dirty="$PS1_CHAR_BISECT "
  elif [[ -e $top/.git/MERGE_HEAD ]]; then
    dirty="$PS1_CHAR_MERGE "
  elif [[ -e $top/.git/rebase-merge ]]; then
    dirty="$PS1_CHAR_REBASE "
  elif [[ $'\n'$status == *$'\n'?[!\ ]* ]]; then
    dirty="$PS1_CHAR_DIRTY "
  elif [[ $'\n'$status == *$'\n'[!\ ]* ]]; then
    dirty="$PS1_CHAR_STAGED "
  fi
  if [[ -n $dirty ]]; then
    fg=$PS1_COLOR_WARNING_FG bg=$PS1_COLOR_WARNING_BG
  else
    fg=$PS1_COLOR_SUCCESS_FG bg=$PS1_COLOR_SUCCESS_BG
  fi
  ps1_segment "$fg" "$bg" "$PS1_CHAR_BRANCH $branch$dirty"
}
ps1_register_module git

# MODULE: svn -- show the subversion source and revision
ps1_mod_svn() {
  $(ps1_cache_get _CWD_IS_SLOW) && return 1
  if [[ $(ps1_cache_get SVN_CWD) != "$PWD" ]]; then
    ps1_cache_set SVN_TOP "$(find_parent_with --far .svn)"
    ps1_cache_set SVN_CWD "$PWD"
  fi
  declare top=$(ps1_cache_get SVN_TOP)
  [[ -n $top ]] || return

  declare rev
  declare rev=$(svn info $top 2>/dev/null | while read data; do
      case $data in
        (Revision:*) echo "${data#*: }" ;;
      esac
    done)
  [[ -n $rev ]] || return

  declare dirty fg bg
  dirty=$(svn status -q | grep -q . && echo "$PS1_CHAR_DIRTY ")
  if [[ -n $dirty ]]; then
    fg=$PS1_COLOR_WARNING_FG bg=$PS1_COLOR_WARNING_BG
  else
    fg=$PS1_COLOR_SUCCESS_FG bg=$PS1_COLOR_SUCCESS_BG
  fi
  ps1_segment "$fg" "$bg" "$PS1_CHAR_SVN $rev$dirty"
}
ps1_register_module svn

ps1_mod_docker() {
  $(ps1_cache_get _CWD_IS_SLOW) && return 1

  if [[ -e docker-compose.yml ]]; then
    ps1_cache_set 'docker top' "$PWD"
  elif [[ $(ps1_cache_get 'docker cwd') != "$PWD" ]]; then
    ps1_cache_set 'docker top' "$(find_parent_with docker-compose.yml)"
  fi
  ps1_cache_set 'docker cwd' "$PWD"
  declare top="$(ps1_cache_get 'docker top')"
  [[ -n $top ]] || return

  #if docker-compose -f "$top/docker-compose.yml" port web 8000 &>/dev/null; then
  if (docker-compose ps -q; docker ps --filter=status=running -q --no-trunc) | sort | uniq -d | grep -q .; then
    ps1_micro "$(ps1_color bright yellow)"$'\uf0e7'  # lightning bolt
  fi
}
ps1_register_module docker

ps1_mod_vagrant() {
  $(ps1_cache_get _CWD_IS_SLOW) && return 1

  if [[ -e Vagrantfile ]]; then
    ps1_cache_set VAGRANT_TOP "$PWD"
  elif [[ $(ps1_cache_get VAGRANT_CWD) != "$PWD" ]]; then
    ps1_cache_set VAGRANT_TOP "$(find_parent_with Vagrantfile)"
  fi
  ps1_cache_set VAGRANT_CWD "$PWD"
  declare top="$(ps1_cache_get VAGRANT_TOP)"
  [[ -n $top ]] || return

  # Lots of fast hacks here, avoid calling slow programs
  declare docker_id_file=$top/.vagrant/machines/default/docker/id \
    libvirt_id_file=$top/.vagrant/machines/default/libvirt/id
  if [[ -e $docker_id_file ]]; then
    declare docker_id=$(<$docker_id_file)
    if [[ -n $docker_id ]]; then
      declare docker_status=$(
        docker ps --filter id="$docker_id" --format '{{.Status}}'
      )
      if [[ ${docker_status,,} == up* ]]; then
        ps1_micro "$(ps1_color bright yellow)"$'\uf0e7'  # lightning bolt
      fi
    fi
  elif [[ -e $libvirt_id_file ]]; then
    declare libvirt_id=$(<$libvirt_id_file)
    if [[ -n $libvirt_id ]]; then
      declare virsh_domstate=$(virsh domstate "$libvirt_id" 2>/dev/null)
      if [[ $virsh_domstate == running ]]; then
        ps1_micro "$(ps1_color bright yellow)"$'\uf0e7'  # lightning bolt
      fi
    fi
  fi
}
ps1_register_module vagrant

# MODULE: user and host
ps1_mod_user() {
  _ps1_segment "$PS1_COLOR_DEFAULT_FG" "$PS1_COLOR_DEFAULT_BG" '\u@\h'
}
#ps1_register_module user after micro

# MODULE: current working directory
ps1_mod_cwd() {
  _ps1_segment "$PS1_COLOR_DEFAULT_FG" "$PS1_COLOR_DEFAULT_BG" '\W'
}
ps1_register_module cwd

# The ps1_update function calls the modules defined above and in the user
# bashrc to construct the full prompt.
ps1_update() {
  declare x

  # help out the modules by caching isslow for cwd
  if [[ -z $(ps1_cache_get _CWD_IS_SLOW) || $PWD != "$(ps1_cache_get _CWD)" ]]; then
    if [[ $PWD == "$HOME" ]]; then
      if [[ -z $(ps1_cache_get _HOME_IS_SLOW) ]]; then
        ps1_cache_set _HOME_IS_SLOW $(bool isslow .)
      fi
      ps1_cache_set _CWD_IS_SLOW $_HOME_IS_SLOW
    else
      ps1_cache_set _CWD_IS_SLOW $(bool isslow .)
    fi
    ps1_cache_set _CWD "$PWD"
  fi
  PS1_CACHE_ISSLOW_CWD=$(ps1_cache_get _CWD_IS_SLOW)  # backward compat

  # clean slate
  PS1=

  # run the status line modules
  PS1_MODS_RAN=()
  for x in "${PS1_MODULES[@]}"; do
    ps1_mod_"$x" && PS1_MODS_RAN+=("$x")
  done
  PS1_CACHE_MODS_RAN=( "${PS1_MODS_RAN[@]}" )  # backward compat

  # cap it off
  PS1+=$(
    echo -n ' '
    if [[ $(ps1_cache_get _BG default) != default ]]; then
      ps1_color reset $(ps1_cache_get _BG)  # reset to kill inverse
      echo -n "$PS1_CHAR_SEP_FILLED "
      ps1_color off
    else
      ps1_color off
      echo -n "${PS1:+ }$PS1_CHAR_SEP "
    fi
  )

  # postprocess
  for x in "${PS1_MODS_RAN[@]}"; do
    x="ps1_mod_${x}_postprocess"
    [[ $(type -t "$x") != function ]] || "$x"
  done
}

# Okay, all functions are defined, now set up PROMPT_COMMAND to make sure things
# are called.  First capture the error status, second save and unset -x, third
# call our ps1_update function, fourth set the xterm title, fifth reset -x.

PROMPT_COMMAND='PS1_ERROR=$?'
append_cmd PROMPT_COMMAND 'PS1_SAVE_SET_X=${-//[^x]/}; [[ -n $PS1_DEBUG ]] || set +x'
append_cmd PROMPT_COMMAND ps1_update
case "$TERM" in
  xterm*|gnome|rxvt*|vte*)
    ps1_update_xterm_title() {
      declare title="${1:-$XTERMTITLE}"
      if [[ -z $title ]]; then
        title="${HOSTNAME%%.*}:${PWD/#$HOME/~}"
      fi
      echo -ne '\033]0;'
      echo -n "$title"
      echo -ne '\007'
    }
    append_cmd PROMPT_COMMAND ps1_update_xterm_title
    ;;
esac
if [[ $(type -t __vte_prompt_command) == function ]]; then
  # https://gnunn1.github.io/tilix-web/manual/vteconfig/
  append_cmd PROMPT_COMMAND __vte_prompt_command
fi
append_cmd PROMPT_COMMAND '[[ -n $PS1_SAVE_SET_X ]] && set -x'

# The following lines enforce a consistent indentation for this file.
# Keep this comment at the end of file.
#
# Local Variables:
# mode: shell-script
# sh-basic-offset: 2
# indent-tabs-mode: nil
# End:
#
# vim:shiftwidth=2 expandtab smarttab
