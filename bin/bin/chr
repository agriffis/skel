#!/bin/bash
# $Id: chr 4036 2010-04-13 23:16:41Z agriffis $
# 
# chr -- chroot as a normal user
#
# Copyright 2007 Aron Griffis <agriffis@n01se.net>
# Released under the GNU GPL v2
#
# This script automates some typical tasks for chroots:
# - switches to the normal user automatically inside the chroot
# - uses linux32 automatically for 32-bit chroots
# - sets the CHROOTED environment variable, intended for use in bash's prompt,
#   such as PS1="\${CHROOTED:+(\$CHROOTED) }$PS1"
# - can execute commands as the normal user, such as
#   chr fedora32 firefox

# many users don't have the sbins in PATH
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH

: ${CHROOTS:=/chroots}

main() {
    declare dum version
    read dum version dum <<<'$Revision: 4036 $'

    # Use /usr/bin/getopt which supports GNU-style long options
    unset ${!opt_*}
    declare opt_sync_group=false
    declare opt_sync_passwd=false
    declare opt_list=false
    declare args getopt_long=$(set | sed '
        /^opt_/!d; s/^opt_//; s/_/-/g; s/=\(false\|true\)$//; s/=.*/:/' | \
        xargs | sed 's/ /,/g')
    args=$(POSIXLY_CORRECT=1 getopt -o gp \
        --long "$getopt_long,help,version" -n "$0" -- "$@") || return
    eval set -- "$args"
    while true; do
        case $1 in
               --list) opt_list=true; shift ;;
            -g|--sync-group) opt_sync_group=true; shift ;;
            -p|--sync-passwd) opt_sync_passwd=true; shift ;;
               --help) usage; exit 0 ;;
               --version) echo "${0##*/} $version"; exit 0 ;;
            --) shift; break ;;
            *) die "failed to process cmdline args" ;;
        esac
    done

    if $opt_sync_passwd || $opt_sync_group; then
        $opt_sync_passwd && sync_chroot passwd "$@"
        $opt_sync_group  && sync_chroot group  "$@"
        exit 0
    fi

    if $opt_list || [[ -z "$1" ]]; then
        show_chroots
        exit 0
    fi

    declare r=$(expand_chroot "$1")
    [[ -n $r ]] || exit # die will emit an error, but can't exit
    shift

    # handle 32-bit chroots in a 64-bit environment (and vice versa, kinda)
    declare setarch
    if type -p linux32 &>/dev/null && \
        [[ $(uname -m) == x86_64 && $(file $r/bin/bash) == *32-bit* ]]
    then
        setarch=linux32
    elif type -p linux64 &>/dev/null && \
        [[ $(uname -m) == i?86 && $(file $r/bin/bash) == *64-bit* ]]
    then
        setarch=linux64
    fi

    # try to maintain $USER in the chroot.
    # $USER isn't set in cron.
    : ${USER:=$(id -un)}
    if grep -q "^$USER:" $r/etc/passwd; then
        # if a command was given, run it as $USER, otherwise start a shell.
        # note cwd is preserved if possible.
        export CHROOTED=${r##?*/}
        if [[ -n $* ]]; then
            exec sudo -E $setarch chroot $r su $USER -c \
                "cd $(printf %q "$PWD") 2>/dev/null || cd; \
                exec $(printf '%q ' "$@")"
        else
            exec sudo -E $setarch chroot $r sh -c \
                "cd $(printf %q "$PWD") 2>/dev/null || cd ~$USER 2>/dev/null; \
                exec su $USER"
        fi
    else
        exec sudo $setarch chroot $r su -
    fi
    
    die "failed to exec"
}

expand_chroot() {
    # if $1 isn't a full dirname, glob to find something
    declare r=$1
    if [[ ! -d $r ]]; then
        r=$(shopt -s nullglob
            set -- "$CHROOTS"/{$r*,*$r,*$r*,$r}
            [[ -d $1 ]] && echo "$1")
    fi
    if [[ ! -d $r ]]; then
        die "no such chroot"
    fi
    echo "$r"
}

show_chroots() {
    declare r f
    for r in "$CHROOTS"/*; do
        printf "%-15s" "${r##*/}"
        ( source "$r"/etc/lsb-release || exit
          echo -n "$DISTRIB_ID"
          echo -n "${DISTRIB_RELEASE:+ $DISTRIB_RELEASE}"
          echo "${DISTRIB_CODENAME:+ ($DISTRIB_CODENAME)}"
        ) 2>/dev/null && continue
        for f in "$r"/etc/{{redhat,gentoo,SuSE}-release,debian_version}; do
            head -n1 "$f" 2>/dev/null && continue 2
        done
        echo unknown
    done
}

collect() {
    declare what=$1 f=$2 lower=500 upper=65000 not
    [[ $what == synched ]] && not='!'
    if [[ /$f == */passwd ]]; then
        awk -F: "$not(\$3<$lower||\$3>$upper||\$6!~/^\\/home/){print}" "$f"
    elif [[ /$f == */group ]]; then
        awk -F: "$not(\$3<$lower||\$3>$upper){print}" "$f"
    else
        die "don't understand collect $f"
    fi
}

get_sudoers() {
    sort | awk -F: '$1=="sudo" || $1=="wheel" {print $4; exit}'
}

set_sudoers() {
    declare text=$1 sudoers=$2 grp=wheel
    grep -q '^sudo:' <<<"$text" && grp=sudo
    awk -F: -v grp="$grp" -v sudoers="$sudoers" \
        'BEGIN{OFS=":"} $1==grp{$4=sudoers} {print}' <<<"$text"
}

sync_chroot() {
    declare unsynched synched sudoers
    declare stamp=$(date +%Y%m%d-%T)
    declare f=/etc/$1
    shift

    if [[ $# == 0 ]]; then
        set -- "$CHROOTS"/*
    fi

    # collect synched lines from the master file
    synched=$(collect synched "$f")
    if [[ /$f == */group ]]; then
        sudoers=$(get_sudoers < "$f")
    fi

    declare r chrf chrsudo
    for r; do
        r=$(expand_chroot "$r") || continue
        chrf=$r$f
        [[ -f $chrf ]] || continue

        # collect unsynched lines from the chroot file
        unsynched=$(collect unsynched "$chrf")
        if [[ /$f == */group ]]; then
            unsynched=$(set_sudoers "$unsynched" "$sudoers")
        fi

        # backup the chroot file
        mv "$chrf" "$chrf.sync-$stamp"

        # munge them to make the new chroot file
        rm -f "$chrf"
        printf "%s\n%s\n" "$unsynched" "$synched" > "$chrf"

        if cmp "$chrf.sync-$stamp" "$chrf" &>/dev/null; then
            mv "$chrf.sync-$stamp" "$chrf"
        else
            printf '%s\n%s\n' '--------' "$r"
            diff -U0 <(sort -t: -k3 "$chrf.sync-$stamp") <(sort -t: -k3 "$chrf")
        fi
    done
}

usage() {
    cat <<EOT
usage: chr [options] [chroot [command...]]

        --list          show available chroots
    -g  --sync-group    sync master /etc/group to chroot(s)
    -p  --sync-passwd   sync master /etc/passwd to chroot(s)
        --help          show this help
        --version       show version info
EOT
}

die() {
    printf '%s: ' "${0##*/}" >&2
    printf '%s\n' "$@" >&2
    exit 1
}

main "$@"
