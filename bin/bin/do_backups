#!/bin/bash
#
# Griffis home backup script
# Copyright 2007 Aron Griffis <aron@griffis1.net>
#

echo() {
    printf '%s\n' "$*"
}

die() {
    [[ -z $* ]] || echo "$cmd: error: $*" >&2
    exit 1
}

date() {
    : ${DATE:=$(command date)}
    if [[ $# -gt 0 ]]; then
        command date -d "$DATE" "$@"
    else
        echo "$DATE"
    fi
}

exec 3>&1
dry() {
    echo "$*" >&3
    $opt_dryrun || "$@" 3>&-
}

sudo() {
    if [[ $UID == 0 ]]; then
        command "$@"
    else
        command sudo "$@"
    fi
}

backup() {
    declare filename="$bdir"/$(date '+%Y%m%d')-$1.dump.gpg
    echo
    echo "+-----------------------------------------------------------"
    echo "| backing up $b ($1) to"
    echo "| $filename"
    echo "+-----------------------------------------------------------"
    echo

    # use an lvm snapshot if possible
    declare snapdev
    if sudo lvs /dev/$dev &>/dev/null; then
        snapdev=$dev-backup-snapshot
        dry sudo lvcreate --snapshot -n ${snapdev##*/} -L 10G /dev/$dev || snapdev=
    fi

    case $host in
        ${HOSTNAME%%.*}) dry sudo nice dump -${1}u -j1 -f- /dev/${snapdev:-$dev} ;;
        *) dry ssh root@$host nice dump -${1}u -j1 -f- /dev/${snapdev:-$dev} ;;
    esac | dry gpg --no-options --encrypt \
        -r aron'@'griffis1.net -r amy'@'griffis1.net -o- >"$filename.part"
    if [[ "${PIPESTATUS[*]}" == *[^\ 0]* ]]; then
        exit_status=1
        echo
        echo "Warning: command exited with non-zero status."
        echo "Renaming file to indicate possible failure."
        declare newf="${filename%.*}.failed"
        mv -v "$filename.part" "$newf"
        ls -l "$newf"
        echo
    elif $opt_dryrun; then
        rm -f "$filename.part"
    else
        echo
        mv "$filename.part" "$filename"
        ls -l "$filename"
        echo
    fi

    # remove the lvm snapshot
    if [[ -n $snapdev ]]; then
        dry sudo lvremove -f /dev/$snapdev
    fi
}

newest() {
    /bin/ls -td *${1:+-$1}.dump.gpg 2>/dev/null | \
        sed -n "${2}p;${2}q"
}

remount_dir() {
    declare dir=$1 vol vg lv errors
    [[ -d $dir/lost+found ]] && return 0
    shift

    errors=$(
        exec 2>&1 3>&1
        dry sudo umount -vf "$dir"
        for vol; do
            vg=${vol#/dev/}; vg=${vg%%/*}
            lv=${vol##*/}
            dry sudo lvchange -a n /dev/mapper/$vg-$lv
            dry sudo vgreduce --removemissing $vg
            dry sudo vgchange -a n $vg
            dry sudo dmsetup remove /dev/mapper/$vg-$lv
        done
        dry sudo pvscan
        dry sudo vgscan
        dry sudo lvscan
        for vol; do
            vg=${vol#/dev/}; vg=${vg%%/*}
            lv=${vol##*/}
            dry sudo vgchange -a y $vg
            dry sudo mount -v $vol $dir && exit 0
        done
        exit 1) && return 0

    printf "\n%s\n%s\n%s\n%s\n\n" >&2 \
        "remount_dir failed, errors follow" \
        "---------------------------------" \
        "$errors" \
        "---------------------------------"
    return 1
}

set_dev() {
    declare kpartx_dev kpartx_part
    case "$1" in
        jabberwock:jubjub)
            kpartx_dev=/dev/mapper/vg_jabberwock-jubjub kpartx_part=1 ;;
        jabberwock:oliva)
            kpartx_dev=/dev/mapper/vg_jabberwock-oliva kpartx_part=1 ;;
        jabberwock:tumtum-boot)
            kpartx_dev=/dev/mapper/vg_jabberwock-tumtum2 kpartx_part=1 ;;
        jabberwock:tumtum-root)
            # This doesn't work because it's a physical volume. Need to
            # treat tumtum as a remote host instead.
            kpartx_dev=/dev/mapper/vg_jabberwock-tumtum2 kpartx_part=5 ;;
        *)
            die "$(printf "set_dev: don't know %q" "$1")" ;;
    esac
    if [[ -n $kpartx_dev ]]; then
        add_cleanup "dry sudo kpartx -dv $kpartx_dev"
        dry sudo kpartx -dv "$kpartx_dev"
        dry sudo kpartx -av "$kpartx_dev"
        if [[ $kpartx_dev == *[0-9] ]]; then
            kpartx_part=p$kpartx_part
        fi
        dev="${kpartx_dev#/dev/}$kpartx_part"
    fi
}

######################################################################
# Main
######################################################################

main() {
# This is the default list of backups; might be modified by cmdline
declare backups=(
    # home directories
    jabberwock:amg:vg_jabberwock/amg
    jabberwock:agriffis:vg_jabberwock/agriffis

    # data
    jabberwock:keep:vg_jabberwock/keep
#   jabberwock:space:raidb_vg/space

    # jabberwock
    jabberwock:root:vg_jabberwock/jabberwock_root
    jabberwock:boot:disk/by-uuid/cd2f67c8-e6c0-4847-a4c6-f79f7c993a30
    jabberwock:old:vg_jabberwock/old_jabberwock

    # guests
#   jabberwock:jubjub
#   jabberwock:oliva
#   jabberwock:tumtum-boot
#   jabberwock:tumtum-root

    # nfs roots
    #jabbewrock:nord:vg_jabberwock/nord
    #jabbewrock:nord:vg_jabberwock/sud

    # other hosts
#   asiago:asiago:sdb1
)
declare cmd=${0##*/}
declare exit_status=0
declare opt_dryrun=false
declare opt_list=false
declare opt_offsite=false
declare opt_remount=false
declare opt_rsync=false
declare opt_verbose=false
declare usage
read -d '' usage <<EOT
usage: $cmd [-n] [backups...]

    -l     --list          List available backups
    -n     --dry-run       Don't backup, just show the commands
    -h     --help          Show this help message
    -r     --remount       Don't backup, just remount /back*
    -s     --rsync         Don't backup, just rsync backup to backdown
    -v     --verbose       Run verbosely (bash -x)
EOT

# Use /usr/bin/getopt which supports GNU-style long options
declare args
args=$(getopt -o hlnrsv --long dry-run,help,list,remount,rsync,verbose -n "$0" -- "$@") || die
eval set -- "$args"
while true; do
    case $1 in
        -l|--list) opt_list=true; shift ;;
        -n|--dry-run) opt_dryrun=true; shift ;;
        -h|--help) echo "$usage"; exit 0 ;;
        -r|--remount) opt_remount=true; shift ;;
        -s|--rsync) opt_rsync=true; shift ;;
        -v|--verbose) opt_verbose=true; shift ;;
        --) shift; break ;;
        *) die "failed to process cmdline args" ;;
    esac
done

$opt_verbose && set -x

# Filter the backups based on the cmdline, some examples:
#   piment              => piment:root:md0 piment:boot:sda1
#   piment:root         => piment:root:md0
#   piment:special:usb0 => piment:special:usb0
if [[ $# -gt 0 ]]; then
    declare new_backups=()

    for (( i=1; i<=$#; i++ )); do
        if [[ ${!i} == *:*:* ]]; then
            # Full spec given, use it verbatim
            new_backups[${#new_backups[@]}]="${!i}"
        else
            # Partial spec given, find matches from original backups array
            for (( j=0; j<${#backups[@]}; )); do
                if [[ :${backups[j]}: == *:"${!i}":* ]]; then
                    new_backups[${#new_backups[@]}]="${backups[j]}"
                    backups=( "${backups[@]:0:j}" "${backups[@]:j+1}" )
                else
                    let j++
                fi
            done
        fi
    done

    backups=( "${new_backups[@]}" )
    unset new_backups
fi

$opt_list && { printf "%s\n" "${backups[@]}"; exit 0; }

remount_dir /backup /dev/backup_vg/backup || die
remount_dir /backdown /dev/backdown1_vg/backdown1 /dev/backdown2_vg/backdown2 \
&& backdown=true || backdown=false

$opt_remount && exit 0

declare tmpdir
cleanup() {
    cd / # so umount works
    rm -rf "$tmpdir"
    dry df -h /backup /backdown
    dry sudo umount /backdown /backup
}
trap 'cleanup; exit' 0 1 2 3 15

add_cleanup() {
    eval "cleanup() {
        $1
        $(type cleanup | sed '1,3d;$d')
    }"
}

declare limit0 limit1 limit2
tmpdir=$(mktemp -d) || die
limit0="$tmpdir"/limit0; touch -d '40 days ago' "${limit0}" # '1 year ago'
limit1="$tmpdir"/limit1; touch -d '10 days ago' "${limit1}" # '1 month ago'
limit2="$tmpdir"/limit2; touch -d '6 hours ago' "${limit2}"

declare host label dev slash bdir
for b in "${backups[@]}"; do
    host=${b%%:*}
    label=${b#*:} ; label=${label%%:*}
    [[ $b == *:*:* ]] && dev=${b##*:} || set_dev $b
    slash=/
    bdir=/backup/$host/$label-${dev//$slash/_}
    rsync_opts=( \
        $([[ -t 0 ]] && echo --progress) \
        -rv --times --size-only \
        --exclude lost+found --exclude \*.failed --exclude \*.part \
    )

    if $opt_offsite; then
        if [[ -d $bdir ]]; then
            dry ssh -l agriffis -o "BatchMode yes" griffis1.net \
                mkdir -p "${bdir#/}"
            dry nice rsync "${rsync_opts[@]}" \
                --rsh 'ssh -l agriffis -o "BatchMode yes"' \
                --bwlimit=40 \
                --append --partial --delete-after \
                "$bdir/" "griffis1.net:${bdir#/}/"
            case $? in
                0)      ;; # Success
                1)  die ;; # Syntax or usage error
                2)  die ;; # Protocol incompatibility
                3)      ;; # Errors selecting input/output files, dirs
                4)  die ;; # Requested action not supported: an attempt was
                           # made to manipulate 64-bit files on a platform
                           # that cannot) support them; or an option was
                           # specified that is supported by the client and
                           # not by the server.
                5)      ;; # Error starting client-server protocol
                6)      ;; # Daemon unable to append to log-file
                10)     ;; # Error in socket I/O
                11)     ;; # Error in file I/O
                12)     ;; # Error in rsync protocol data stream
                13)     ;; # Errors with program diagnostics
                14)     ;; # Error in IPC code
                20) die ;; # Received SIGUSR1 or SIGINT
                21)     ;; # Some error returned by waitpid()
                22)     ;; # Error allocating core memory buffers
                23)     ;; # Partial transfer due to error
                24)     ;; # Partial transfer due to vanished source files
                25) die ;; # The --max-delete limit stopped deletions
                30)     ;; # Timeout in data send/receive
                *)  die ;; # Unknown error
            esac
        fi
        continue
    fi

    if $backdown && [[ -e $bdir ]]; then
        echo
        echo "+-----------------------------------------------------------"
        echo "| rsyncing $bdir to /backdown"
        echo "+-----------------------------------------------------------"
        echo
        dry sudo mkdir -p "/backdown/${bdir#/backup/}"
        dry sudo nice rsync "${rsync_opts[@]}" --delete \
            "$bdir/" "/backdown/${bdir#/backup/}" || exit_status=1
    fi

    $opt_rsync && continue

    mkdir -p "$bdir" || continue
    cd "$bdir" || continue  # needed for newest()

    if [[ -z $(newest 0) || $(newest 0) -ot "${limit0}" ]]; then
        # do level 0 dump once every 40 days
        backup 0
    elif [[ $(newest '[01]') -ot "${limit1}" ]]; then
        # do level 1 dump once every 10 days
        backup 1
    elif [[ $(newest) -ot "${limit2}" ]]; then
        # Tower of Hanoi algo from dump(8) for 9 days
        case $(newest | sed 's/.*-\([0-9]\).*/\1/') in
            0|1) backup 3 ;;
            3) backup 2 ;;
            2) backup 5 ;;
            5) backup 4 ;;
            4) backup 7 ;;
            7) backup 6 ;;
            6) backup 9 ;;
            9) backup 8 ;;
            8) backup 9 ;;
        esac
    else
        echo "Skipping $b"
    fi

    (   declare testf

        # Remove level 2-9 backups for which we have three more recent 
        # level 0/1 backups
        testf=$(newest '[01]' 3)
        if [[ -n $testf ]]; then
            find "$bdir" -type f -name \*-[2-9].dump.gpg ! -newer "$testf" -print0
        fi

        # Remove level 1 backups for which we have two more recent 
        # level 0 backups
        testf=$(newest 0 2)
        if [[ -n $testf ]]; then
            find "$bdir" -type f -name \*-1.dump.gpg ! -newer "$testf" -print0
        fi

        # Remove level 0 backups for which we have five or more recent 
        # level 0 backups
        testf=$(newest 0 6)
        if [[ -n $testf ]]; then
            find "$bdir" -type f -name \*-0.dump.gpg ! -newer "$testf" -print0
        fi
    ) | (
        if $opt_dryrun; then
            xargs -0 echo rm -fv
        else
            xargs -0 rm -fv
        fi
    )
done

exit $exit_status
}

main "$@"
